#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Outil de synchronisation inter-logiciels
D√©velopp√© par: Paul-KERHERVE
Date: 2025-05-06
"""

#==============================================================================
# SECTION 1: IMPORTS ET CONFIGURATION
#==============================================================================

import os
import csv
import subprocess
import tempfile
import datetime
import shutil
import sys

# Configuration des correspondances entre colonnes
CORRESPONDANCE_COLONNES = {
    "var": "variable",
    "tel": "telephone", 
    "id_client": "id",
    "nom": "nom_client",
    "prenom": "prenom_client",
    "email": "adresse_email",
    "statut": "status_client",
    "categorie": "cat_client",
}

# Configuration des colonnes √† synchroniser
COLONNES_A_SYNCHRONISER = [
    "nom", "prenom", "tel", "email", "statut", "categorie"
]

# Configuration des correspondances pour valeurs fixes (menus d√©roulants)
ATTRIBUTS_MENUS_DEROULANTS = {
    "statut": {
        "A": "Actif",
        "I": "Inactif",
        "P": "En attente",
        "B": "Bloqu√©",
    },
    "categorie": {
        "PRO": "Professionnel",
        "PART": "Particulier",
        "ASSOC": "Association",
        "ADMIN": "Administration",
    },
}

# Configuration des chemins
CHEMIN_SHAREPOINT = r"Z:\Dossier Partag√©\Synchronisation"

# Dossier de travail par d√©faut (peut √™tre modifi√© par l'utilisateur)
DOSSIER_TRAVAIL_DEFAUT = "Music/projet"

# Identifiant unique pour lier les enregistrements entre les deux fichiers
COLONNE_ID_SOURCE = "id_client"
COLONNE_ID_CIBLE = "id"


#==============================================================================
# SECTION 2: CONVERSION DE FICHIERS XLSX VERS CSV
#==============================================================================

def convert_xlsx_to_csv(xlsx_path, csv_path, timeout=300):
    """
    Convertit un fichier XLSX en CSV via Excel/VBScript.
    
    Args:
        xlsx_path: Chemin du fichier XLSX source
        csv_path: Chemin du fichier CSV de destination
        timeout: Temps maximum d'attente en secondes (d√©faut: 5 minutes)
    
    Returns:
        bool: True si succ√®s, False sinon
    """
    print(f"Conversion de {xlsx_path} vers {csv_path}...")
    
    # Chemin absolu avec √©chappement des backslashes
    abs_xlsx = os.path.abspath(xlsx_path).replace('\\', '\\\\')
    abs_csv = os.path.abspath(csv_path).replace('\\', '\\\\')
    
    # Script VBS avec gestion d'erreurs basique
    vbs_content = f"""
    On Error Resume Next
    Set Excel = CreateObject("Excel.Application")
    If Err.Number <> 0 Then
        WScript.Quit 1
    End If
    
    Excel.Visible = False
    Excel.DisplayAlerts = False
    
    Set WB = Excel.Workbooks.Open("{abs_xlsx}")
    If Err.Number <> 0 Then
        Excel.Quit
        WScript.Quit 2
    End If
    
    WB.SaveAs "{abs_csv}", 6  ' 6 = Format CSV
    If Err.Number <> 0 Then
        WB.Close False
        Excel.Quit
        WScript.Quit 3
    End If
    
    WB.Close
    Excel.Quit
    WScript.Quit 0
    """
    
    # √âcrire et ex√©cuter le script VBS
    fd, vbs_path = tempfile.mkstemp(suffix='.vbs')
    try:
        with os.fdopen(fd, 'w') as f:
            f.write(vbs_content)
        
        process = subprocess.Popen(['cscript', '//NoLogo', vbs_path], 
                                  stdout=subprocess.PIPE,
                                  stderr=subprocess.PIPE)
        
        stdout, stderr = process.communicate(timeout=timeout)
        if process.returncode == 0:
            print("Conversion r√©ussie!")
            return True
        else:
            print(f"Erreur lors de la conversion: code {process.returncode}")
            if process.returncode == 2:
                print("Excel n'a pas pu ouvrir le fichier. V√©rifiez qu'il n'est pas ouvert dans une autre application.")
            return False
            
    except Exception as e:
        print(f"Erreur lors de la conversion: {str(e)}")
        return False
    finally:
        # Nettoyer le fichier temporaire
        try:
            os.unlink(vbs_path)
        except:
            pass


#==============================================================================
# SECTION 3: MANIPULATION ET TRANSFORMATION DES DONN√âES
#==============================================================================

def map_value(value, column_name):
    """
    Mappe une valeur si elle correspond √† un menu d√©roulant.
    
    Args:
        value: La valeur √† transformer
        column_name: Le nom de la colonne
    
    Returns:
        La valeur transform√©e ou la valeur originale
    """
    # V√©rifier si c'est une valeur de menu d√©roulant √† mapper
    if column_name in ATTRIBUTS_MENUS_DEROULANTS and value in ATTRIBUTS_MENUS_DEROULANTS[column_name]:
        return ATTRIBUTS_MENUS_DEROULANTS[column_name][value]
    
    # Sinon, retourner la valeur non modifi√©e
    return value


def read_csv_file(filepath, id_column):
    """
    Lit un fichier CSV et retourne un dictionnaire index√© par l'identifiant.
    
    Args:
        filepath: Chemin du fichier CSV √† lire
        id_column: Nom de la colonne contenant l'identifiant unique
        
    Returns:
        Tuple (dictionnaire de donn√©es, liste des ent√™tes)
    """
    print(f"Lecture du fichier {filepath}...")
    data = {}
    headers = []
    
    try:
        with open(filepath, 'r', encoding='utf-8', newline='') as csvfile:
            reader = csv.reader(csvfile)
            headers = next(reader)  # Lire les ent√™tes
            
            # Trouver l'index de la colonne ID
            try:
                id_index = headers.index(id_column)
            except ValueError:
                print(f"Erreur: Colonne '{id_column}' non trouv√©e dans {filepath}")
                print(f"Colonnes disponibles: {', '.join(headers)}")
                return {}, headers
            
            # Lire les donn√©es et indexer par ID
            row_count = 0
            for row in reader:
                row_count += 1
                if len(row) <= id_index:
                    print(f"Attention: Ligne {row_count} ignor√©e (nombre de colonnes insuffisant)")
                    continue
                    
                if row[id_index].strip():
                    data[row[id_index]] = {headers[i]: row[i] for i in range(len(row))}
                else:
                    print(f"Attention: Ligne {row_count} ignor√©e (ID manquant)")
        
        print(f"Lecture termin√©e: {len(data)} enregistrements charg√©s")
        return data, headers
        
    except UnicodeDecodeError:
        print(f"Erreur: Probl√®me d'encodage dans {filepath}")
        print("Le fichier n'est peut-√™tre pas encod√© en UTF-8. Tentative avec un encodage alternatif...")
        try:
            # Essayer avec l'encodage ISO-8859-1 (Latin-1)
            with open(filepath, 'r', encoding='latin-1', newline='') as csvfile:
                reader = csv.reader(csvfile)
                headers = next(reader)
                
                try:
                    id_index = headers.index(id_column)
                except ValueError:
                    print(f"Erreur: Colonne '{id_column}' non trouv√©e dans {filepath}")
                    return {}, headers
                
                for row in reader:
                    if len(row) > id_index and row[id_index].strip():
                        data[row[id_index]] = {headers[i]: row[i] for i in range(len(row))}
            
            print(f"Lecture termin√©e (encodage latin-1): {len(data)} enregistrements charg√©s")
            return data, headers
        except Exception as e:
            print(f"√âchec de la lecture alternative: {str(e)}")
            return {}, headers
    except Exception as e:
        print(f"Erreur lors de la lecture du fichier {filepath}: {str(e)}")
        print(f"Type d'erreur: {type(e).__name__}")
        return {}, headers


#==============================================================================
# SECTION 4: SYNCHRONISATION DES DONN√âES
#==============================================================================

def synchronize_data(source_data, target_data, columns_to_sync):
    """
    Synchronise les donn√©es source vers les donn√©es cible.
    
    Args:
        source_data: Dictionnaire des donn√©es source
        target_data: Dictionnaire des donn√©es cible
        columns_to_sync: Liste des colonnes √† synchroniser
        
    Returns:
        Tuple (donn√©es mises √† jour, statistiques)
    """
    print("Synchronisation des donn√©es...")
    stats = {
        "total_source": len(source_data),
        "total_target": len(target_data),
        "matched": 0,
        "updated": 0,
        "unchanged": 0,
        "not_found": 0,
        "values_mapped": 0
    }
    
    # Pour chaque enregistrement dans la source
    for source_id, source_record in source_data.items():
        # Trouver l'enregistrement correspondant dans la cible
        if source_id in target_data:
            stats["matched"] += 1
            target_record = target_data[source_id]
            
            # Compter les changements pour cet enregistrement
            changes_for_record = 0
            
            # Pour chaque colonne √† synchroniser
            for source_col in columns_to_sync:
                # Trouver la colonne correspondante dans la cible
                target_col = CORRESPONDANCE_COLONNES.get(source_col, source_col)
                
                # V√©rifier si la colonne existe dans les deux fichiers
                if source_col in source_record and target_col in target_record:
                    # Traiter les valeurs de menus d√©roulants
                    original_value = source_record[source_col]
                    mapped_value = map_value(original_value, source_col)
                    
                    # Compter les mappings appliqu√©s
                    if original_value != mapped_value:
                        stats["values_mapped"] += 1
                    
                    # Si les valeurs sont diff√©rentes, mettre √† jour
                    if mapped_value != target_record[target_col]:
                        target_data[source_id][target_col] = mapped_value
                        changes_for_record += 1
            
            if changes_for_record > 0:
                stats["updated"] += 1
            else:
                stats["unchanged"] += 1
        else:
            stats["not_found"] += 1
    
    print(f"Synchronisation termin√©e:")
    print(f"  - {stats['matched']} enregistrements correspondants trouv√©s")
    print(f"  - {stats['updated']} enregistrements mis √† jour")
    print(f"  - {stats['unchanged']} enregistrements inchang√©s")
    print(f"  - {stats['not_found']} enregistrements non trouv√©s dans la cible")
    print(f"  - {stats['values_mapped']} valeurs de menus d√©roulants mapp√©es")
    
    return target_data, stats


#==============================================================================
# SECTION 5: GESTION DES FICHIERS (SAUVEGARDE ET √âCRITURE)
#==============================================================================

def write_csv_file(data, headers, filepath):
    """
    √âcrit les donn√©es dans un fichier CSV.
    
    Args:
        data: Dictionnaire des donn√©es √† √©crire
        headers: Liste des ent√™tes de colonnes
        filepath: Chemin du fichier de sortie
        
    Returns:
        bool: True si succ√®s, False sinon
    """
    print(f"√âcriture du fichier {filepath}...")
    try:
        with open(filepath, 'w', encoding='utf-8', newline='') as csvfile:
            writer = csv.writer(csvfile)
            
            # √âcrire les ent√™tes
            writer.writerow(headers)
            
            # √âcrire les donn√©es
            for record_id, record in data.items():
                row = [record.get(header, "") for header in headers]
                writer.writerow(row)
        
        print(f"√âcriture termin√©e: {len(data)} enregistrements √©crits")
        return True
        
    except Exception as e:
        print(f"Erreur lors de l'√©criture du fichier {filepath}: {str(e)}")
        return False


def create_backup(filepath):
    """
    Cr√©e une sauvegarde d'un fichier.
    
    Args:
        filepath: Chemin du fichier √† sauvegarder
        
    Returns:
        str: Chemin du fichier de sauvegarde
    """
    if not os.path.exists(filepath):
        return None
    
    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_path = f"{filepath}.{timestamp}.bak"
    
    try:
        shutil.copy2(filepath, backup_path)
        print(f"Sauvegarde cr√©√©e: {backup_path}")
        return backup_path
    except Exception as e:
        print(f"Erreur lors de la cr√©ation de la sauvegarde: {str(e)}")
        return None


#==============================================================================
# SECTION 6: FONCTIONS DE CONFIGURATION ET D'AIDE
#==============================================================================

def setup_working_directory():
    """
    Configure le r√©pertoire de travail et affiche les informations de session.
    
    Returns:
        bool: True si le r√©pertoire a √©t√© configur√© avec succ√®s, False sinon
    """
    print("=== OUTIL DE SYNCHRONISATION INTER-LOGICIELS ===")
    print(f"D√©marr√© le {datetime.datetime.now().strftime('%Y-%m-%d √† %H:%M:%S')}")
    print(f"Utilisateur: {os.environ.get('USERNAME', 'Inconnu')}")
    
    original_dir = os.getcwd()
    print(f"R√©pertoire de travail initial: {original_dir}")
    
    # Demander le r√©pertoire de travail
    use_custom_dir = input(f"Utiliser un r√©pertoire de travail sp√©cifique? (o/N): ").lower() == 'o'
    
    if use_custom_dir:
        work_dir = input(f"Chemin du r√©pertoire de travail (d√©faut: {DOSSIER_TRAVAIL_DEFAUT}): ")
        if not work_dir.strip():
            work_dir = DOSSIER_TRAVAIL_DEFAUT
    else:
        work_dir = DOSSIER_TRAVAIL_DEFAUT
    
    # Changer le r√©pertoire de travail
    try:
        os.chdir(work_dir)
        current_dir = os.getcwd()
        print(f"R√©pertoire de travail chang√© pour: {current_dir}")
        
        # Lister les fichiers CSV et XLSX disponibles
        print("\nFichiers disponibles dans ce r√©pertoire:")
        found_files = False
        for file in os.listdir('.'):
            if file.endswith('.csv') or file.endswith('.xlsx'):
                print(f"  - {file}")
                found_files = True
        
        if not found_files:
            print("  Aucun fichier CSV ou XLSX trouv√© dans ce r√©pertoire")
            print(f"  Contenu du r√©pertoire: {', '.join(os.listdir('.'))}")
        
        return True
        
    except FileNotFoundError:
        print(f"Erreur: Le r√©pertoire '{work_dir}' n'existe pas.")
        create_dir = input(f"Voulez-vous cr√©er ce r√©pertoire? (o/N): ").lower() == 'o'
        
        if create_dir:
            try:
                os.makedirs(work_dir)
                os.chdir(work_dir)
                print(f"R√©pertoire cr√©√© et d√©fini comme r√©pertoire de travail: {work_dir}")
                return True
            except Exception as e:
                print(f"Erreur lors de la cr√©ation du r√©pertoire: {str(e)}")
                return False
        return False
        
    except PermissionError:
        print(f"Erreur: Acc√®s refus√© au r√©pertoire '{work_dir}'.")
        print("V√©rifiez que vous avez les autorisations n√©cessaires.")
        return False
        
    except Exception as e:
        print(f"Erreur lors du changement de r√©pertoire: {str(e)}")
        return False


def test_file_access(filepath):
    """
    Teste l'acc√®s √† un fichier et affiche des informations de diagnostic.
    
    Args:
        filepath: Chemin du fichier √† tester
        
    Returns:
        bool: True si le fichier est accessible, False sinon
    """
    print(f"\nTest d'acc√®s pour: {filepath}")
    
    # V√©rifier si le fichier existe
    if not os.path.exists(filepath):
        print(f"  ‚ùå Le fichier n'existe pas!")
        print(f"  üìÇ R√©pertoire de travail actuel: {os.getcwd()}")
        return False
    
    print(f"  ‚úÖ Le fichier existe")
    
    # Tester l'acc√®s en lecture
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            first_chars = f.read(50)
            print(f"  ‚úÖ Lecture r√©ussie! Premiers caract√®res: {first_chars[:20]}...")
            return True
    except PermissionError:
        print(f"  ‚ùå Permission refus√©e pour lire le fichier")
        return False
    except UnicodeDecodeError:
        print(f"  ‚ö†Ô∏è Probl√®me d'encodage UTF-8, tentative avec Latin-1...")
        try:
            with open(filepath, 'r', encoding='latin-1') as f:
                first_chars = f.read(50)
                print(f"  ‚úÖ Lecture r√©ussie avec Latin-1! Premiers caract√®res: {first_chars[:20]}...")
                return True
        except Exception as e2:
            print(f"  ‚ùå Erreur de lecture avec Latin-1: {str(e2)}")
            return False
    except Exception as e:
        print(f"  ‚ùå Erreur de lecture: {type(e).__name__}: {str(e)}")
        return False


#==============================================================================
# SECTION 7: FONCTION PRINCIPALE
#==============================================================================

def main():
    """Fonction principale du script."""
    try:
        # Configurer le r√©pertoire de travail
        if not setup_working_directory():
            print("Configuration du r√©pertoire de travail √©chou√©e. Utilisation du r√©pertoire par d√©faut.")
        
        # Demander les fichiers source et cible (noms simples, pas chemins complets)
        source_path = input("\nNom du fichier source (CSV ou XLSX): ")
        target_path = input("Nom du fichier cible (CSV ou XLSX): ")
        
        # Tester l'acc√®s aux fichiers
        source_accessible = test_file_access(source_path)
        target_accessible = test_file_access(target_path)
        
        if not source_accessible or not target_accessible:
            print("\nProbl√®me d'acc√®s aux fichiers. V√©rifiez les noms et les permissions.")
            input("Appuyez sur Entr√©e pour quitter...")
            return
        
        # Cr√©er des chemins temporaires pour les fichiers CSV
        temp_dir = tempfile.mkdtemp()
        source_csv = source_path
        target_csv = target_path
        
        # Convertir en CSV si n√©cessaire
        if source_path.lower().endswith('.xlsx'):
            source_csv = os.path.join(temp_dir, "source_temp.csv")
            if not convert_xlsx_to_csv(source_path, source_csv):
                print("Erreur: Impossible de convertir le fichier source en CSV.")
                input("Appuyez sur Entr√©e pour quitter...")
                return
        
        if target_path.lower().endswith('.xlsx'):
            target_csv = os.path.join(temp_dir, "target_temp.csv")
            if not convert_xlsx_to_csv(target_path, target_csv):
                print("Erreur: Impossible de convertir le fichier cible en CSV.")
                input("Appuyez sur Entr√©e pour quitter...")
                return
        
        # Lire les donn√©es
        source_data, source_headers = read_csv_file(source_csv, COLONNE_ID_SOURCE)
        target_data, target_headers = read_csv_file(target_csv, COLONNE_ID_CIBLE)
        
        if not source_data:
            print("Erreur: Aucune donn√©e valide trouv√©e dans le fichier source.")
            input("Appuyez sur Entr√©e pour quitter...")
            return
            
        if not target_data:
            print("Erreur: Aucune donn√©e valide trouv√©e dans le fichier cible.")
            input("Appuyez sur Entr√©e pour quitter...")
            return
        
        # Cr√©er une sauvegarde du fichier cible
        backup_path = create_backup(target_path)
        if not backup_path:
            confirmation = input("Attention: Impossible de cr√©er une sauvegarde du fichier cible. Continuer quand m√™me? (o/N): ")
            if confirmation.lower() != 'o':
                print("Op√©ration annul√©e.")
                input("Appuyez sur Entr√©e pour quitter...")
                return
        
        # Synchroniser les donn√©es
        updated_data, stats = synchronize_data(source_data, target_data, COLONNES_A_SYNCHRONISER)
        
        # G√©n√©rer le nom du fichier de sortie
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M")
        output_filename = f"donn√©es_synchronis√©es_{timestamp}.csv"
        
        # √âcrire le fichier de sortie local
        if write_csv_file(updated_data, target_headers, output_filename):
            print(f"Fichier mis √† jour cr√©√©: {output_filename}")
            
            # Si le chemin SharePoint est sp√©cifi√© et accessible, copier le fichier
            if CHEMIN_SHAREPOINT and os.path.exists(CHEMIN_SHAREPOINT) and os.path.isdir(CHEMIN_SHAREPOINT):
                copy_to_sharepoint = input(f"Copier le fichier r√©sultat vers SharePoint ({CHEMIN_SHAREPOINT})? (o/N): ").lower() == 'o'
                if copy_to_sharepoint:
                    sharepoint_output_path = os.path.join(CHEMIN_SHAREPOINT, output_filename)
                    try:
                        shutil.copy2(output_filename, sharepoint_output_path)
                        print(f"Fichier copi√© sur SharePoint: {sharepoint_output_path}")
                    except Exception as e:
                        print(f"Erreur lors de la copie vers SharePoint: {str(e)}")
                        print(f"Le fichier est disponible localement: {output_filename}")
        else:
            print("Erreur lors de l'√©criture du fichier de sortie.")
            input("Appuyez sur Entr√©e pour quitter...")
            return
        
        # Nettoyer les fichiers temporaires
        try:
            shutil.rmtree(temp_dir)
        except:
            pass
        
        print("\nSynchronisation termin√©e avec succ√®s!")
        print(f"R√©sum√©: {stats['updated']} enregistrements mis √† jour sur {stats['matched']} correspondants")
        
    except KeyboardInterrupt:
        print("\nOp√©ration interrompue par l'utilisateur.")
    except Exception as e:
        print(f"\nUne erreur inattendue s'est produite: {str(e)}")
        import traceback
        traceback.print_exc()
    
    print("==================================================")
    # Attendre une touche pour fermer
    input("Appuyez sur Entr√©e pour quitter...")


if __name__ == "__main__":
    main()
